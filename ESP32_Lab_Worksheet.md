# ‡πÉ‡∏ö‡∏á‡∏≤‡∏ô‡∏ó‡∏î‡∏•‡∏≠‡∏á: ‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏™‡∏ñ‡∏≤‡∏õ‡∏±‡∏ï‡∏¢‡∏Å‡∏£‡∏£‡∏° ESP32
## ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏î‡πâ‡∏ß‡∏¢ Docker ‡πÅ‡∏•‡∏∞ QEMU

**‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠**: ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏ñ‡∏≤‡∏õ‡∏±‡∏ï‡∏¢‡∏Å‡∏£‡∏£‡∏° ESP32 ‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥ ‡πÅ‡∏•‡∏∞ Dual-Core CPU  
**‡∏£‡∏≤‡∏¢‡∏ß‡∏¥‡∏ä‡∏≤**: 2568.01 APPLICATIONS OF MICROCONTROLLERS  
**‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà**: 5  
**‡πÄ‡∏ß‡∏•‡∏≤**: 3 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á  

---

## üìã ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ô‡∏µ‡πâ ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ:

1. **‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏™‡∏ñ‡∏≤‡∏õ‡∏±‡∏ï‡∏¢‡∏Å‡∏£‡∏£‡∏° ESP32** - ‡∏£‡∏∞‡∏ö‡∏ö dual-core, memory mapping, cache system
2. **‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Docker ‡πÅ‡∏•‡∏∞ QEMU** - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå microcontroller
3. **‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå Memory Architecture** - ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á
4. **‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô Cache Performance** - ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö memory access patterns
5. **‡∏®‡∏∂‡∏Å‡∏©‡∏≤ Dual-Core System** - ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á PRO_CPU ‡πÅ‡∏•‡∏∞ APP_CPU
6. **‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠ Analysis** - objdump, QEMU monitor

---

## üõ†Ô∏è ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠

### Software Requirements
- **Docker Desktop** (‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡πâ‡∏ß)
- **VS Code** ‡∏û‡∏£‡πâ‡∏≠‡∏° Docker Extension
- **Git** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö clone repository
- **Web Browser** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π documentation

### Hardware Requirements
- **Computer** ‡∏û‡∏£‡πâ‡∏≠‡∏° RAM ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 4 GB
- **Internet Connection** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö download Docker images
- **Storage Space** ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 GB ‡∏ß‡πà‡∏≤‡∏á

---

## üìö ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô

‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏ó‡∏ö‡∏ó‡∏ß‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö:
- ESP32 Architecture (‡∏≠‡πà‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå ESP32_Architecture.md)
- Docker containers ‡πÅ‡∏•‡∏∞ basic commands
- Memory management concepts
- Command line interface (bash/cmd)

---

## üî¨ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° Environment (‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢)

### ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
- ‡πÉ‡∏ä‡πâ Docker ‡πÅ‡∏•‡∏∞ ESP-IDF ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏à‡∏≤‡∏Å Lab4 
- ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° workspace ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏®‡∏∂‡∏Å‡∏©‡∏≤ ESP32 architecture
- ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå

### ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

#### **Step 1.1: ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å docker-compose.yml ‡∏à‡∏≤‡∏Å Lab4**

```bash
# ‡∏™‡∏£‡πâ‡∏≤‡∏á directory ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Lab5
mkdir ESP32-Architecture-Lab
cd ESP32-Architecture-Lab

# ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å docker-compose.yml ‡∏à‡∏≤‡∏Å Lab4 (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
# ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå docker-compose.yml ‡πÉ‡∏´‡∏°‡πà
```

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `docker-compose.yml` (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô Lab4):

```yaml
version: '3.8'

services:
  esp32-dev:
    image: espressif/idf:latest
    container_name: esp32-lab5
    volumes:
      - .:/project
    working_dir: /project
    tty: true
    stdin_open: true
    environment:
      - IDF_PATH=/opt/esp/idf
    command: /bin/bash
    networks:
      - esp32-network

networks:
  esp32-network:
    driver: bridge
```

#### **Step 1.2: ‡∏£‡∏±‡∏ô Docker Environment (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Lab4)**

```bash
# ‡∏£‡∏±‡∏ô container (‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢)
docker-compose up -d

# ‡πÄ‡∏Ç‡πâ‡∏≤ container (‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢)
docker-compose exec esp32-dev bash
```

#### **Step 1.3: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ESP-IDF ‡πÅ‡∏•‡∏∞‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°**

```bash
# ‡πÉ‡∏ô container - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ESP-IDF (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Lab4)
echo $IDF_PATH
. $IDF_PATH/export.sh
idf.py --version
xtensa-esp32-elf-gcc --version

# ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö architecture analysis
apt-get update
apt-get install -y tree htop

# ‡∏™‡∏£‡πâ‡∏≤‡∏á directories ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Lab5
mkdir -p {memory-test,cache-test,dual-core-test,results}
```

#### **Step 1.4: ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Environment ‡∏û‡∏£‡πâ‡∏≠‡∏°**

```bash
# ‡∏ó‡∏î‡∏™‡∏≠‡∏ö build ‡∏á‡πà‡∏≤‡∏¢‡πÜ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Lab4)
echo '#include <stdio.h>
void app_main() {
    printf("ESP32 Architecture Lab Ready\\n");
}' > test.c

echo "=== Environment Ready for ESP32 Architecture Analysis ==="
echo "Docker: Working"
echo "ESP-IDF: Ready"
echo "Tools: tree, htop installed"
echo "Ready for Lab5 experiments!"
```

### üîç ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏à‡∏≤‡∏Å Lab4

#### **‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö Lab4:**
- **docker-compose.yml** - ‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô Lab4
- **‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á Docker** - `docker-compose up -d`, `docker-compose exec esp32-dev bash`
- **ESP-IDF environment** - ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢‡πÅ‡∏•‡πâ‡∏ß
- **‡∏Å‡∏≤‡∏£ build ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°** - `idf.py build` ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°

#### **‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏ô Lab5:**
- **Directory ‡πÉ‡∏´‡∏°‡πà** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö architecture analysis
- **‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏á‡πà‡∏≤‡∏¢‡πÜ** tree, htop
- **Focus ‡πÉ‡∏´‡∏°‡πà** ESP32 architecture ‡πÅ‡∏ó‡∏ô arithmetic

**‡πÇ‡∏ï‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Directory ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏¥‡πà‡∏ô‡∏™‡∏∏‡∏î Lab 5** 
```
ESP32-Architecture-Lab/          # ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á Lab5
‚îú‚îÄ‚îÄ docker-compose.yml           # ‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏≤‡∏Å Lab4 (‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏°‡∏≤)
‚îú‚îÄ‚îÄ memory-test/                 # ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 2: Memory Architecture
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt           # root project file
‚îÇ   ‚îú‚îÄ‚îÄ main/                    # ESP-IDF main component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory_test.c        # source code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö memory
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt       # component file
‚îÇ   ‚îî‚îÄ‚îÄ build/                   # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠ build (auto-generated)
‚îú‚îÄ‚îÄ cache-test/                  # ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 3: Cache Performance  
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt           # root project file
‚îÇ   ‚îú‚îÄ‚îÄ main/                    # ESP-IDF main component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache_test.c         # source code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö cache
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt       # component file
‚îÇ   ‚îî‚îÄ‚îÄ build/                   # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠ build (auto-generated)
‚îú‚îÄ‚îÄ dual-core-test/              # ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 4: Dual-Core Analysis
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt           # root project file
‚îÇ   ‚îú‚îÄ‚îÄ main/                    # ESP-IDF main component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dual_core_test.c     # source code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö dual-core
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt       # component file
‚îÇ   ‚îî‚îÄ‚îÄ build/                   # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠ build (auto-generated)
‚îî‚îÄ‚îÄ results/                     # ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á
    ‚îú‚îÄ‚îÄ memory_analysis.txt      # ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå memory
    ‚îú‚îÄ‚îÄ cache_performance.txt    # ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö cache
    ‚îú‚îÄ‚îÄ dual_core_results.txt    # ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö dual-core
    ‚îî‚îÄ‚îÄ analysis_report.md       # ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á
```

### ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏ö‡∏ó‡∏ß‡∏ô

1. **Docker Commands**: ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `docker-compose up -d` ‡πÅ‡∏•‡∏∞ `docker-compose exec esp32-dev bash` ‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£?
2. **ESP-IDF Tools**: ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÑ‡∏´‡∏ô‡∏à‡∏≤‡∏Å Lab4 ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ build ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ESP32?
3. **New Tools**: ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á (tree, htop) ‡πÉ‡∏ä‡πâ‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£?
4. **Architecture Focus**: ‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤ ESP32 architecture ‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ arithmetic ‡πÉ‡∏ô Lab4 ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£?

### ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå ESP32-Architecture-Lab ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢
- [ ] ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á docker-compose.yml ‡πÑ‡∏î‡πâ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
- [ ] ‡∏£‡∏±‡∏ô Docker container ‡πÑ‡∏î‡πâ‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Lab4)
- [ ] ‡πÄ‡∏Ç‡πâ‡∏≤ container ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ ESP-IDF ‡πÑ‡∏î‡πâ (‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏à‡∏≤‡∏Å Lab4)
- [ ] ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (tree, htop) ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á directories ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á architecture ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢

### ü§ñ ‡∏Ç‡πâ‡∏≠‡∏î‡∏µ‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢

**‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ docker-compose.yml ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Lab4:**
- **‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡πÉ‡∏´‡∏°‡πà**: ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß
- **‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤**: ‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏µ‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ Docker setup ‡πÉ‡∏´‡∏°‡πà
- **‡πÇ‡∏ü‡∏Å‡∏±‡∏™ ESP32**: ‡πÄ‡∏ô‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤ architecture ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠
- **‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à**: ‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà work ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å Lab4

---

## üî¨ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 2: ‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤ Memory Architecture

### ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏î‡∏™‡∏≠‡∏ö memory layout
- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡πÉ‡∏ô ESP32
- ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à address mapping ‡πÅ‡∏•‡∏∞ memory sections

### ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

#### **Step 2.1: ‡∏™‡∏£‡πâ‡∏≤‡∏á Memory Test Project**

```bash
# ‡πÉ‡∏ô container - ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô memory-test directory
cd /project/memory-test

# ‡∏™‡∏£‡πâ‡∏≤‡∏á src directory ‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå main
mkdir -p main
```

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `main/memory_test.c`:

```c
#include <stdio.h>
#include <string.h>
#include <esp_system.h>
#include <esp_heap_caps.h>
#include <esp_attr.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

// Global variables in different memory sections
DRAM_ATTR static char sram_buffer[1024];  // Explicitly place in DRAM using ESP32 attribute
static const char flash_string[] = "Hello from Flash Memory!";  // This will be in .rodata (Flash) automatically
static char *heap_ptr;

// Function to display memory information
void print_memory_info() {
    printf("\n=== ESP32 Memory Layout Analysis ===\n");
    
    // Stack variables (in SRAM)
    int stack_var = 42;
    printf("Stack variable address: 0x%08lx\n", (unsigned long)&stack_var);
    
    // Global SRAM buffer
    printf("SRAM buffer address:    0x%08lx\n", (unsigned long)sram_buffer);
    
    // Flash constant string
    printf("Flash string address:   0x%08lx\n", (unsigned long)flash_string);
    
    // Heap allocation
    heap_ptr = malloc(512);
    printf("Heap allocation:        0x%08lx\n", (unsigned long)heap_ptr);
    
    // Heap information
    printf("\n=== Heap Information ===\n");
    printf("Free heap size:         %lu bytes\n", (unsigned long)esp_get_free_heap_size());
    printf("Min free heap size:     %lu bytes\n", (unsigned long)esp_get_minimum_free_heap_size());
    printf("Largest free block:     %lu bytes\n", (unsigned long)heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT));
    
    // Memory usage by type
    printf("\n=== Memory Usage by Type ===\n");
    printf("Internal SRAM:          %lu bytes\n", (unsigned long)heap_caps_get_free_size(MALLOC_CAP_INTERNAL));
    printf("SPI RAM (if available): %lu bytes\n", (unsigned long)heap_caps_get_free_size(MALLOC_CAP_SPIRAM));
    printf("DMA capable memory:     %lu bytes\n", (unsigned long)heap_caps_get_free_size(MALLOC_CAP_DMA));
    
    free(heap_ptr);
}

void app_main() {
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° delay ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ serial port ‡∏û‡∏£‡πâ‡∏≠‡∏°
    vTaskDelay(100 / portTICK_PERIOD_MS);
    
    printf("=== ESP32 STARTING UP ===\n");
    printf("ESP32 Memory Architecture Analysis\n");
    printf("==================================\n");
    
    // Flush output buffer
    fflush(stdout);
    
    // Test memory operations
    strcpy(sram_buffer, "SRAM Test Data");
    printf("Flash string: %s\n", flash_string);
    printf("SRAM buffer: %s\n", sram_buffer);
    
    fflush(stdout);
    
    print_memory_info();
    
    printf("\nMemory analysis complete!\n");
    fflush(stdout);
}
```

#### **Step 2.2: ‡∏™‡∏£‡πâ‡∏≤‡∏á CMake Configuration**

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `CMakeLists.txt` (‡πÉ‡∏ô memory-test directory):

```cmake
cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(memory_test)
```

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `main/CMakeLists.txt`:

```cmake
idf_component_register(SRCS "memory_test.c"
                    INCLUDE_DIRS ".")
```




#### **Step 2.3: Build ‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå Binary**

```bash
# Build project (‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏ô‡πÄ‡∏Ñ‡∏¢‡∏à‡∏≤‡∏Å Lab4)
# ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô /project/memory-test directory ‡πÅ‡∏•‡πâ‡∏ß
idf.py build

# ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå binary file ‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
echo "=== Binary Analysis ==="
xtensa-esp32-elf-size build/memory_test.elf
xtensa-esp32-elf-objdump -h build/memory_test.elf | head -20

# ‡∏î‡∏π memory sections ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
echo "=== Memory Sections ==="
xtensa-esp32-elf-objdump -t build/memory_test.elf | grep -E "(sram_buffer|flash_string|app_main)"
```

#### **Step 2.4: ‡∏£‡∏±‡∏ô Program ‡πÉ‡∏ô QEMU ‡πÅ‡∏•‡∏∞‡∏î‡∏π‡∏ú‡∏•**

```bash
# ‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÉ‡∏ô QEMU emulator (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ hardware ‡∏à‡∏£‡∏¥‡∏á)
idf.py qemu 


# ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ build ‡πÉ‡∏´‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏±‡∏ô
# idf.py build qemu 

# ‡∏Å‡∏î Ctrl+] ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å monitor
# ‡∏î‡∏π‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á memory addresses
```

‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏ ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å docker (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ exec ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô docker) ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ‡∏ö‡∏ô cmd terminal

```bash 
# build
  docker exec -it esp32-lab5 bash -c "source /opt/esp/idf/export.sh && cd memory-test && idf.py build"

# ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡πâ‡∏ß‡∏¢
   docker exec -it esp32-lab5 bash -c "source /opt/esp/idf/export.sh && cd memory-test && idf.py qemu"

# ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡πâ‡∏ß‡∏¢
   Ctrl+z
```

**üñ•Ô∏è ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏´‡πá‡∏ô‡πÉ‡∏ô QEMU:**
```
ESP32 Memory Architecture Analysis
==================================
Flash string: Hello from Flash Memory!
SRAM buffer: SRAM Test Data

=== ESP32 Memory Layout Analysis ===
Stack variable address: 0x3ffbxxxx
SRAM buffer address:    0x3ffcxxxx  
Flash string address:   0x400xxxxx
Heap allocation:        0x3ffcxxxx

=== Heap Information ===
Free heap size:         xxxxxx bytes
Min free heap size:     xxxxxx bytes
Largest free block:     xxxxxx bytes

=== Memory Usage by Type ===
Internal SRAM:          xxxxxx bytes
SPI RAM (if available): 0 bytes
DMA capable memory:     xxxxxx bytes

Memory analysis complete!
```

### ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á 

**Table 2.1: Memory Address Analysis**

| Memory Section | Variable/Function | Address (‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏≠‡∏Å‡∏°‡∏≤) | Memory Type |
|----------------|-------------------|----------------------|-------------|
| Stack | stack_var | 0x3ffb4550 | SRAM |
| Global SRAM | sram_buffer |  0x3ffb16ac | SRAM |
| Flash | flash_string |  0x3f407b64 | Flash |
| Heap | heap_ptr | 0x3ffb5264 | SRAM |

**Table 2.2: Memory Usage Summary**

| Memory Type | Free Size (bytes) | Total Size (bytes) |
|-------------|-------------------|--------------------|
| Internal SRAM |  380096 byte | 520,192 |
| Flash Memory |0 bytes | varies |
| DMA Memory |  303096 bytes | varies |

### ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå (‡∏á‡πà‡∏≤‡∏¢)

1. **Memory Types**: SRAM ‡πÅ‡∏•‡∏∞ Flash Memory ‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏´‡∏ô?
2. **Address Ranges**: ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô address range ‡πÑ‡∏´‡∏ô?
3. **Memory Usage**: ESP32 ‡∏°‡∏µ memory ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏£ ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏£?

---

## üî¨ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 3: ‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤ Cache Performance

### ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
- ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö cache performance ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á sequential ‡πÅ‡∏•‡∏∞ random access
- ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏Ç‡∏≠‡∏á cache hit/miss ‡∏ï‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå memory access patterns

### ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

#### **Step 3.1: ‡∏™‡∏£‡πâ‡∏≤‡∏á Cache Performance Test**

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `main/cache_test.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <esp_timer.h>
#include <esp_heap_caps.h>

#define ARRAY_SIZE 4096
#define ITERATIONS 100
#define TEST_RUNS 5

// Test arrays in different memory locations
static uint32_t sram_array[ARRAY_SIZE];
static uint32_t *psram_array = NULL;

// Performance measurement functions
uint64_t measure_sequential_access(uint32_t *array, const char* memory_type) {
    uint64_t start_time = esp_timer_get_time();
    uint32_t sum = 0;
    
    for(int run = 0; run < TEST_RUNS; run++) {
        for(int iter = 0; iter < ITERATIONS; iter++) {
            for(int i = 0; i < ARRAY_SIZE; i++) {
                sum += array[i];
            }
        }
    }
    
    uint64_t end_time = esp_timer_get_time();
    uint64_t duration = end_time - start_time;
    
    printf("%s Sequential Access: %llu Œºs (sum=%lu)\n", memory_type, duration, (unsigned long)sum);
    return duration;
}

uint64_t measure_random_access(uint32_t *array, const char* memory_type) {
    uint64_t start_time = esp_timer_get_time();
    uint32_t sum = 0;
    
    for(int run = 0; run < TEST_RUNS; run++) {
        for(int iter = 0; iter < ITERATIONS; iter++) {
            for(int i = 0; i < ARRAY_SIZE; i++) {
                // Pseudo-random index to break cache locality
                int index = (i * 2654435761U) % ARRAY_SIZE;
                sum += array[index];
            }
        }
    }
    
    uint64_t end_time = esp_timer_get_time();
    uint64_t duration = end_time - start_time;
    
    printf("%s Random Access: %llu Œºs (sum=%lu)\n", memory_type, duration, (unsigned long)sum);
    return duration;
}

uint64_t measure_stride_access(uint32_t *array, int stride, const char* test_name) {
    uint64_t start_time = esp_timer_get_time();
    uint32_t sum = 0;
    
    for(int run = 0; run < TEST_RUNS; run++) {
        for(int iter = 0; iter < ITERATIONS; iter++) {
            for(int i = 0; i < ARRAY_SIZE; i += stride) {
                sum += array[i];
            }
        }
    }
    
    uint64_t end_time = esp_timer_get_time();
    uint64_t duration = end_time - start_time;
    
    printf("%s (stride %d): %llu Œºs (sum=%lu)\n", test_name, stride, duration, (unsigned long)sum);
    return duration;
}

void initialize_arrays() {
    printf("Initializing test arrays...\n");
    
    // Initialize SRAM array
    for(int i = 0; i < ARRAY_SIZE; i++) {
        sram_array[i] = i * 7 + 13;  // Some pattern
    }
    
    // Try to allocate PSRAM array (if available)
    psram_array = heap_caps_malloc(ARRAY_SIZE * sizeof(uint32_t), MALLOC_CAP_SPIRAM);
    if(psram_array) {
        printf("PSRAM array allocated successfully\n");
        for(int i = 0; i < ARRAY_SIZE; i++) {
            psram_array[i] = i * 7 + 13;
        }
    } else {
        printf("PSRAM not available, using internal memory\n");
        psram_array = heap_caps_malloc(ARRAY_SIZE * sizeof(uint32_t), MALLOC_CAP_INTERNAL);
        if(psram_array) {
            for(int i = 0; i < ARRAY_SIZE; i++) {
                psram_array[i] = i * 7 + 13;
            }
        }
    }
}

void app_main() {
    printf("ESP32 Cache Performance Analysis\n");
    printf("================================\n");
    
    printf("Array size: %d elements (%d KB)\n", ARRAY_SIZE, (ARRAY_SIZE * 4) / 1024);
    printf("Iterations per test: %d\n", ITERATIONS);
    printf("Test runs: %d\n\n", TEST_RUNS);
    
    initialize_arrays();
    
    // Test 1: Sequential vs Random Access (SRAM)
    printf("\n=== Test 1: Sequential vs Random Access (Internal SRAM) ===\n");
    uint64_t sram_sequential = measure_sequential_access(sram_array, "SRAM");
    uint64_t sram_random = measure_random_access(sram_array, "SRAM");
    
    double sram_ratio = (double)sram_random / sram_sequential;
    printf("SRAM Performance Ratio (Random/Sequential): %.2fx\n", sram_ratio);
    
    // Test 2: External Memory (if available)
    if(psram_array) {
        printf("\n=== Test 2: External Memory Access ===\n");
        uint64_t psram_sequential = measure_sequential_access(psram_array, "External");
        uint64_t psram_random = measure_random_access(psram_array, "External");
        
        double psram_ratio = (double)psram_random / psram_sequential;
        printf("External Memory Performance Ratio: %.2fx\n", psram_ratio);
        
        printf("\nMemory Type Comparison (Sequential Access):\n");
        double memory_ratio = (double)psram_sequential / sram_sequential;
        printf("External/Internal Speed Ratio: %.2fx\n", memory_ratio);
    }
    
    // Test 3: Different Stride Patterns
    printf("\n=== Test 3: Stride Access Patterns ===\n");
    uint64_t stride1 = measure_stride_access(sram_array, 1, "Stride 1");
    uint64_t stride2 = measure_stride_access(sram_array, 2, "Stride 2");
    uint64_t stride4 = measure_stride_access(sram_array, 4, "Stride 4");
    uint64_t stride8 = measure_stride_access(sram_array, 8, "Stride 8");
    uint64_t stride16 = measure_stride_access(sram_array, 16, "Stride 16");
    
    printf("\nStride Analysis:\n");
    printf("Stride 2/1 ratio: %.2fx\n", (double)stride2/stride1);
    printf("Stride 4/1 ratio: %.2fx\n", (double)stride4/stride1);
    printf("Stride 8/1 ratio: %.2fx\n", (double)stride8/stride1);
    printf("Stride 16/1 ratio: %.2fx\n", (double)stride16/stride1);
    
    if(psram_array) {
        free(psram_array);
    }
    
    printf("\nCache performance analysis complete!\n");
}
```

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏**
‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å docker ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ
```bash
 
# build
  docker exec -it esp32-lab5 bash -c "source /opt/esp/idf/export.sh && cd cache-test && idf.py build"

 # ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏î‡πâ‡∏ß‡∏¢
   docker exec -it esp32-lab5 bash -c "source /opt/esp/idf/export.sh && cd cache-test && idf.py qemu"
```

### ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

**Table 3.1: Cache Performance Results**

| Test Type | Memory Type | Time (Œºs) | Ratio vs Sequential |
|-----------|-------------|-----------|-------------------|
| Sequential | Internal SRAM | 10089 | 1.00x |
| Random | Internal SRAM | 13599 | 1.35 |
| Sequential | External Memory |49897 | 49897 |
| Random | External Memory | 37140 | 3.68x |

**Table 3.2: Stride Access Performance**

| Stride Size | Time (Œºs) | Ratio vs Stride 1 |
|-------------|-----------|------------------|
| 1 | 6350 | 1.00x |
| 2 | 3373 | 0.53x |
| 4 | 1631 | 0.26x |
| 8 | 862 | 0.14x |
| 16 | 1199 | 0.19x |

### ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå

1. **Cache Efficiency**: ‡∏ó‡∏≥‡πÑ‡∏° sequential access ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ random access?
2. **Memory Hierarchy**: ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á internal SRAM ‡πÅ‡∏•‡∏∞ external memory ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?
3. **Stride Patterns**: stride size ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏ï‡πà‡∏≠ performance ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£?

---

## üî¨ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 4: ‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤ Dual-Core Architecture

### ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
- ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á PRO_CPU ‡πÅ‡∏•‡∏∞ APP_CPU
- ‡∏®‡∏∂‡∏Å‡∏©‡∏≤ inter-core communication
- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå task scheduling ‡πÅ‡∏•‡∏∞ load balancing

### ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

#### **Step 4.1: ‡∏™‡∏£‡πâ‡∏≤‡∏á Dual-Core Test Program**

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `main/dual_core_test.c`:

```c
#include <stdio.h>
#include <string.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <freertos/semphr.h>
#include <esp_system.h>
#include <esp_timer.h>

// Inter-core communication
static QueueHandle_t core_queue;
static SemaphoreHandle_t print_mutex;

// Performance counters
static volatile uint32_t core0_counter = 0;
static volatile uint32_t core1_counter = 0;
static volatile uint64_t core0_total_time = 0;
static volatile uint64_t core1_total_time = 0;

// Message structure for inter-core communication
typedef struct {
    uint32_t sender_core;
    uint32_t message_id;
    uint64_t timestamp;
    char data[32];
} core_message_t;

void safe_printf(const char* format, ...) {
    xSemaphoreTake(print_mutex, portMAX_DELAY);
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
    xSemaphoreGive(print_mutex);
}

// Task for Core 0 (PRO_CPU)
void core0_task(void *parameter) {
    core_message_t message;
    uint64_t task_start = esp_timer_get_time();
    
    safe_printf("Core 0 Task Started (PRO_CPU)\n");
    
    for(int i = 0; i < 100; i++) {
        uint64_t iteration_start = esp_timer_get_time();
        
        // Simulate protocol processing work
        uint32_t checksum = 0;
        for(int j = 0; j < 1000; j++) {
            checksum += j * 997;  // Some computation
        }
        
        // Send message to Core 1 every 10 iterations
        if(i % 10 == 0) {
            message.sender_core = 0;
            message.message_id = i;
            message.timestamp = esp_timer_get_time();
            snprintf(message.data, sizeof(message.data), "Hello from Core 0 #%d", i);
            
            if(xQueueSend(core_queue, &message, pdMS_TO_TICKS(100)) == pdTRUE) {
                safe_printf("Core 0: Sent message %d\n", i);
            }
        }
        
        core0_counter++;
        uint64_t iteration_time = esp_timer_get_time() - iteration_start;
        core0_total_time += iteration_time;
        
        vTaskDelay(pdMS_TO_TICKS(50));  // 50ms delay
    }
    
    uint64_t task_end = esp_timer_get_time();
    safe_printf("Core 0 Task Completed in %llu ms\n", (task_end - task_start) / 1000);
    vTaskDelete(NULL);
}

// Task for Core 1 (APP_CPU)
void core1_task(void *parameter) {
    core_message_t received_message;
    uint64_t task_start = esp_timer_get_time();
    
    safe_printf("Core 1 Task Started (APP_CPU)\n");
    
    for(int i = 0; i < 150; i++) {
        uint64_t iteration_start = esp_timer_get_time();
        
        // Simulate application processing work
        float result = 0.0;
        for(int j = 0; j < 500; j++) {
            result += sqrt(j * 1.7f);  // Floating point computation
        }
        
        // Check for messages from Core 0
        if(xQueueReceive(core_queue, &received_message, pdMS_TO_TICKS(10)) == pdTRUE) {
            uint64_t latency = esp_timer_get_time() - received_message.timestamp;
            safe_printf("Core 1: Received '%s' (latency: %llu Œºs)\n", 
                       received_message.data, latency);
        }
        
        core1_counter++;
        uint64_t iteration_time = esp_timer_get_time() - iteration_start;
        core1_total_time += iteration_time;
        
        vTaskDelay(pdMS_TO_TICKS(30));  // 30ms delay
    }
    
    uint64_t task_end = esp_timer_get_time();
    safe_printf("Core 1 Task Completed in %llu ms\n", (task_end - task_start) / 1000);
    vTaskDelete(NULL);
}

// Monitoring task (can run on either core)
void monitor_task(void *parameter) {
    TickType_t last_wake_time = xTaskGetTickCount();
    
    for(int i = 0; i < 10; i++) {
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1000));  // Every 1 second
        
        safe_printf("\n=== Performance Monitor (Second %d) ===\n", i + 1);
        safe_printf("Core 0 iterations: %lu (avg: %llu Œºs)\n", 
                   core0_counter, core0_counter > 0 ? core0_total_time / core0_counter : 0);
        safe_printf("Core 1 iterations: %lu (avg: %llu Œºs)\n", 
                   core1_counter, core1_counter > 0 ? core1_total_time / core1_counter : 0);
        safe_printf("Queue messages waiting: %d\n", uxQueueMessagesWaiting(core_queue));
        safe_printf("Free heap: %d bytes\n", esp_get_free_heap_size());
    }
    
    vTaskDelete(NULL);
}

void app_main() {
    printf("ESP32 Dual-Core Architecture Analysis\n");
    printf("=====================================\n");
    
    // Create synchronization objects
    core_queue = xQueueCreate(10, sizeof(core_message_t));
    print_mutex = xSemaphoreCreateMutex();
    
    if(core_queue == NULL || print_mutex == NULL) {
        printf("Failed to create synchronization objects!\n");
        return;
    }
    
    printf("Creating tasks...\n");
    
    // Create tasks pinned to specific cores
    BaseType_t core0_result = xTaskCreatePinnedToCore(
        core0_task,           // Task function
        "Core0Task",          // Name
        4096,                 // Stack size
        NULL,                 // Parameters
        2,                    // Priority
        NULL,                 // Task handle
        0                     // Core 0 (PRO_CPU)
    );
    
    BaseType_t core1_result = xTaskCreatePinnedToCore(
        core1_task,           // Task function
        "Core1Task",          // Name
        4096,                 // Stack size
        NULL,                 // Parameters
        2,                    // Priority
        NULL,                 // Task handle
        1                     // Core 1 (APP_CPU)
    );
    
    BaseType_t monitor_result = xTaskCreate(
        monitor_task,         // Task function
        "MonitorTask",        // Name
        2048,                 // Stack size
        NULL,                 // Parameters
        1,                    // Priority (lower than worker tasks)
        NULL                  // Task handle
    );
    
    if(core0_result != pdPASS || core1_result != pdPASS || monitor_result != pdPASS) {
        printf("Failed to create tasks!\n");
        return;
    }
    
    printf("Tasks created successfully. Monitoring dual-core performance...\n\n");
    
    // Main task becomes idle
    vTaskDelay(pdMS_TO_TICKS(12000));  // Wait 12 seconds
    
    printf("\n=== Final Results ===\n");
    printf("Core 0 total iterations: %lu\n", core0_counter);
    printf("Core 1 total iterations: %lu\n", core1_counter);
    printf("Core 0 average time per iteration: %llu Œºs\n", 
           core0_counter > 0 ? core0_total_time / core0_counter : 0);
    printf("Core 1 average time per iteration: %llu Œºs\n", 
           core1_counter > 0 ? core1_total_time / core1_counter : 0);
    
    printf("\nDual-core analysis complete!\n");
}
```

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏**
‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å docker ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ
```bash
    docker exec -it esp32-lab5 bash -c "source /opt/esp/idf/export.sh && cd dual-core-test && idf.py build"
```

### ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

**Table 4.1: Dual-Core Performance Summary**

| Metric | Core 0 (PRO_CPU) | Core 1 (APP_CPU) |
|--------|-------------------|-------------------|
| Total Iterations | 81 | 101 |
| Average Time per Iteration (Œºs) | 115 | 10176 |
| Total Execution Time (ms) | 4997 | 4997 |
| Task Completion Rate | 100% | 100% |

**Table 4.2: Inter-Core Communication**

| Metric | Value |
|--------|-------|
| Messages Sent | 90 |
| Messages Received | 9 |
| Average Latency (Œºs) | 16957 |
| Queue Overflow Count | 0 |

### ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå

1. **Core Specialization**: ‡∏à‡∏≤‡∏Å‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á core ‡πÑ‡∏´‡∏ô‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÉ‡∏î?
2. **Communication Overhead**: inter-core communication ‡∏°‡∏µ overhead ‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏£?
3. **Load Balancing**: ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á cores ‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?

---

## üìä ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•

### ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ú‡∏•

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `reports/analysis_report.md` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á:


### ‡πÅ‡∏ö‡∏ö‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏™‡πà‡∏á‡∏á‡∏≤‡∏ô

**‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤:**
- ‡∏ä‡∏∑‡πà‡∏≠: _________________________________
- ‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: _______________________
- ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á: ___________________

**Checklist ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á:**
- [ ] Environment setup ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà 4)
- [ ] Memory architecture analysis ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
- [ ] Cache performance testing ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
- [ ] Dual-core analysis ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
- [ ] ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô

**‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô:**
- ‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° Environment ‡πÅ‡∏•‡∏∞ Continuity (15 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô): _______
- Memory Analysis (30 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô): _______
- Cache Performance (25 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô): _______
- Dual-Core Analysis (25 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô): _______
- ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô): _______
- **‡∏£‡∏ß‡∏° (100 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô): _______**

**‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°:**
1. ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Docker ‡πÉ‡∏ô‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ô‡∏µ‡πâ‡∏Å‡∏±‡∏ö‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà 4:
   _________________________________________________

2. ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö ESP32 architecture:
   _________________________________________________

3. ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡πâ‡∏≤‡∏ó‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ architecture analysis:
   _________________________________________________

---

## üìö References ‡πÅ‡∏•‡∏∞ Additional Reading

1. **ESP32 Technical Reference Manual** - Espressif Systems
2. **ESP-IDF Programming Guide** - https://docs.espressif.com/projects/esp-idf/
3. **Docker Documentation** - https://docs.docker.com/
4. **QEMU ESP32 Documentation** - https://github.com/espressif/qemu
5. **FreeRTOS Documentation** - https://www.freertos.org/

---

## üí° Tips ‡πÅ‡∏•‡∏∞ Troubleshooting

### Common Issues
1. **Docker Memory Issues**: ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° memory allocation ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Docker
2. **QEMU Startup Problems**: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö binary format ‡πÅ‡∏•‡∏∞ machine type
3. **Build Errors**: ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ESP-IDF version compatibility

### Performance Tips
1. ‡πÉ‡∏ä‡πâ `-O2` optimization flag ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö realistic performance
2. ‡∏£‡∏±‡∏ô test ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠ average ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
3. Monitor system resources ‡∏Ç‡∏ì‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

### Additional Experiments
1. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö interrupt latency
2. ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå power consumption patterns
3. ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö microcontrollers ‡∏≠‡∏∑‡πà‡∏ô

---

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏**: 
- ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà 4 ‡πÇ‡∏î‡∏¢‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå architecture 
- ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Docker environment ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå
- Container name ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å `esp32-lab4` ‡πÄ‡∏õ‡πá‡∏ô `esp32-lab5` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£
